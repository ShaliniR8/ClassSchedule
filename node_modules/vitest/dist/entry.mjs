import { promises } from 'fs';
import { g as getWorkerState, a as resetModules } from './chunk-utils-global.2aa95025.mjs';
import { f as envs } from './chunk-defaults.ed196a9a.mjs';
import { a as setupGlobalEnv, s as startTests, w as withEnv } from './chunk-runtime-error.606e0393.mjs';
import 'path';
import 'tty';
import 'local-pkg';
import 'module';
import 'url';
import './chunk-runtime-hooks.d4cadf47.mjs';
import './chunk-runtime-chain.f2e00f4c.mjs';
import 'util';
import 'chai';
import './vendor-_commonjsHelpers.4da45ef5.mjs';
import './chunk-runtime-rpc.45d8ee19.mjs';
import './chunk-utils-source-map.8b066ce2.mjs';
import './spy.mjs';
import 'tinyspy';

async function run(files, config) {
  await setupGlobalEnv(config);
  const workerState = getWorkerState();
  if (config.browser) {
    workerState.mockMap.clear();
    await startTests(files, config);
    return;
  }
  const filesWithEnv = await Promise.all(files.map(async (file) => {
    var _a;
    const code = await promises.readFile(file, "utf-8");
    const env = ((_a = code.match(/@(?:vitest|jest)-environment\s+?([\w-]+)\b/)) == null ? void 0 : _a[1]) || config.environment || "node";
    if (!envs.includes(env))
      throw new Error(`Unsupported environment: "${env}" in ${file}`);
    return {
      file,
      env
    };
  }));
  const filesByEnv = filesWithEnv.reduce((acc, { file, env }) => {
    acc[env] || (acc[env] = []);
    acc[env].push(file);
    return acc;
  }, {});
  for (const env of envs) {
    const environment = env;
    const files2 = filesByEnv[environment];
    if (!files2 || !files2.length)
      continue;
    await withEnv(environment, config.environmentOptions || {}, async () => {
      for (const file of files2) {
        workerState.mockMap.clear();
        resetModules();
        workerState.filepath = file;
        await startTests([file], config);
        workerState.filepath = void 0;
      }
    });
  }
}

export { run };
